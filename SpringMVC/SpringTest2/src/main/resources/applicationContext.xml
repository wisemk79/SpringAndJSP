<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

<!-- spring4 (p, c 네임스페이스) 
	xml의 Namespaces에서 p, c를 체크해준다. 

-->
<!-- <bean id="moniter" class="spring4.SystemMoniter">
세터메소드 2개이기 때문에 프로퍼티 2개 생성 
	<property name="periodTime">
		<value>20</value>
	</property>
	<property name="sender">
		<ref bean="smsSender"/>
	</property>
</bean> 
위의 코드를 아래처럼 네임스페이스를 통해 간단하게 작성할 수 있다.

p:속성명="값" p:멤버변수-ref="상대방의 참조하는 구분자 id명"
-->

<!-- spring4 (p, c 네임스페이스) 
	xml의 Namespaces에서 p, c를 체크해준다. 
-->
<bean id="moniter" class="spring4.SystemMoniter" p:periodTime="30" p:sender-ref="smsSender"></bean>


<!-- 아무 생성자도 없기 때문에 객체만 만들어준다.  -->
<bean id="smsSender" class="spring4.SmsSender"></bean>

<!-- spring5(c 네임스페이스) -->
<bean id="moniter2" class="spring5.SystemMoniter" c:periodTime="40" c:sender-ref="smsSender2">
<!-- 	<constructor-arg value="40"/>
	<constructor-arg ref="smsSender2"/> -->
</bean>

<bean id="smsSender2" class="spring5.SmsSender">
</bean>


<bean id="moniter3" class="spring6.SystemMoniter" p:periodTime="80">
	<property name="sender">
	<bean class="spring6.SmsSender">
		<constructor-arg value="true"></constructor-arg>
	</bean>
		<!-- <ref bean="smsSender3"/> -->
</property>

<!-- 	<constructor-arg value="40"/>
	<constructor-arg ref="smsSender2"/> -->
</bean>

<!-- spring6 spring6.SystemMoniter(id=>moniter3)
	setter method
	
	spring6.SmsSender (id=> SmsSender3)
	constructor-arg->true
 -->
<!-- <bean id="smsSender3" class="spring6.SmsSender" c:flag="true"> -->

<!-- 
spring7 
	자료형이 리스트면 list태그를 사용한다.
	List<Double> number;
	bean 태그의 id와 동일한 기능을 가진 속성명 =>name <둘의 사용용도는 다르다.
	
	id=> 특정클래스의 객체를 가져오기 위한 내부적인 구분번호, 특수기호를 사용불가(/,#,특수기호 사용불가)
	name => #,/ 특수기호 사용이 가능하다. 
	현재는 구분하지 않고 사용을 한다.
	
	
	name을 쓰면 jsp 프론트 컨트롤러 처럼  액션 맵핑이 가능해진다. 
	근데 지금버전들은 전부 id를 써도 상관이 없다. 
	/list.do=action.ListAction
	
	<bean name="/lise.do" class="action.ListAction"/> 
-->


<bean id="/performanceMoniter" class="spring7.PerformanceMoniter">
	<property name="number">
		<list>
			<value>0.2</value>
			<value>0.3</value>
		</list>
	</property>
</bean>


<!-- spring8(Set인 경우 어떻게 설정하는가?)

	<set>태그를 사용 
	setSubSet메소드의 매개변수로써 Set자료형의 객체를 전달받는다. (중복되는 값은 하나만 저장-> 1,4)저장 
	저장되는 순서도 정해지지 않음 
 -->
<bean id="customer" class="spring8.Customer">
	<property name="subSet">
		<set>
			<value>1</value>
			<value>1</value>
			<value>4</value>
		</set>
	</property>
</bean>



<!-- spring9(Map) 
	<map>태그를 사용한다. 다만, 벨류값을 넣기위해선 키, 벨류를 <entry>태그로 묶어줘야한다.
	
	map.put("soap", new SoapHandler());
	위의것을 태그로 바꾸면 아래와 같다.=>
	<key><value>soap</value></key>=>키명 
	<ref bean="soapHandler"/>=> 저장할 객체명 
	
	
	map.put("rest", new RestHandler());
	위의것을 태그로 바꾸면 아래와 같다.=>
	<key><value>rest</value></key>=>키명 
	<ref bean="restHandler"/>=> 저장할 객체명
 -->
<bean name="protocolHanderFactory" class="spring9.ProtocolHanderFactory">
	<property name="map">
		<map>
			<entry>
				<key><value>soap</value></key>
				<ref bean="soapHandler"/>
			</entry>
			<entry>
				<key><value>rest</value></key>
				<ref bean="restHandler"/>
			</entry>
		</map>
	</property>
</bean>


<bean name="soapHandler" class="spring9.SoapHandler"/>
<bean name="restHandler" class="spring9.RestHandler"/>


</beans>
